**抓住vue的核心&概念，对比几大框架的优缺点，做项目踩几个坑，一些资源（源码学习、抱大腿）。**`福利：还有redux、ReactNative等项目哦`
> Vue是一套构建用户界面的渐进式框架；是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：vue数据驱动（根据数据的状态）的组件系统。

**数据驱动：**
Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter（所以只兼容`IE9及以上版本`），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。
watcher：每一个指令都会有一个对应的用来观测数据的对象，叫做watcher，比如v-text="msg", {{ msg }}，即为两个watcher，watcher对象中包含了待渲染的关联DOM元素。
```
  <div id="app">
    {{ message }}
  </div>
  var app = new Vue({
    el: '#app',
    data: {
      message: 'Hello Vue!'
    }
  })
```
基于依赖收集的观测机制原理：
> 1. 将原生的数据改造成 “可观察对象”，通常为，调用defineProperty改变data对象中数据为存储器属性。一个可观察对象可以被取值getter，也可以被赋值setter。
2. 在解析模板，也就是在watcher的求值过程中，每一个被取值的可观察对象都会将当前的watcher注册为自己的一个订阅者，并成为当前watcher的一个依赖。
3. 当一个被依赖的可观察对象被赋值时，它会通知notify所有订阅自己的watcher重新求值，并触发相应的更新，即watcher对象中关联的DOM改变渲染。
 
依赖收集的优点在于可以精确、主动地追踪数据的变化，不需要手动触发或对作用域中所有watcher都求值（angular脏检查实现方式的缺点）。特殊的是，对于数组，需要通过包裹数组的可变方法（比如push）来监听数组的变化。在添加/删除属性，或是修改数组特定位置元素时，也需要调用特定的函数，如obj.$add(key, value)才能触发更新。这是受ES5的语言特性所限。

**组件系统：**
应用类UI可以看作全部是由组件树构成的。
注册一个组件：
```
  Vue.component('my-component', {
    // 模板
    template: '<div>{{msg}} {{privateMsg}}</div>',
    // 接受参数
    props: {
      msg: String
    },
    // 私有数据，需要在函数中返回以避免多个实例共享一个对象
    data: function() {
      return {
        privateMsg: 'component!'
      }
    }
  }) 
<my-component msg = "hello" > </my-component>
```

组件的核心选项:
> 1. 模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。
2. 初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。
3. 接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。
4. 方法（methods）：对数据的改动操作一般都在组件的方法内进行。
5. 生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。
6. 私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。

Webpack是一个开源的前端模块构建工具，它提供了`强大的loader API`来`定义对不同文件格式的预处理逻辑`，这是.vue后缀单文件组件形式的基础。所以在此基础上，尤大开发的vue-loader允许将模板、样式、逻辑三要素整合在同一个文件中，以.vue文件后缀形成单文件组件格式，方便项目架构和开发引用。

**props：**函数可以接受外部的输入，然入内部吐出加工之后的结果，在vue中也是如此的，vue的组件允许从外部接收定义好的prop，可以指定相关的数据类型，默认值，是否允许为空，是否双向数据同步，是否单次绑定，这就把vue组件从静态的组件赋予了从外部接受参数，从而实现配置化的能力，举一个例子，一般一个面板需要有可变的标题，底部多少个按钮，是否显示后面的蒙板层，这些都可以从外部接受参数传入，从而达到组件的多样化配置，大大增强了组件的灵活性。

**slot：**那slot呢？既然有了props，为什么还需要slot来做为另一种外部的输入呢？
我们还是以上面的面板做为一个例子，试想一下，有一个panel的函数如下
```
function panel(title,btnCount,showModel,content){
}
```
大家注意到了content了没有，面板的主体内容，一般来说面板的主体内容都比较复杂，这意味着在html标签会十分的多，那么如果在prop里面传入html的模板内容，代码的可维护性将大大的降低，而且十分不优雅，所以vue使用了slot，即所谓的插槽，来实现内容的"props"，它可以在组件内部定义好slot的插入点，外部html插入的时候就能指定一个插入点替换掉这个slot了，我理解的slot就是针对复杂内容的一种外部参数了，那么不复杂的内容是不是就可以不需要了？我个人觉得是的，比如你的面板可能只需要一句话，那大可以使用prop传入即可，比如alert。但是，但是，内容的可替换性还远远不算是slot的唯一不同，这里我想说一下slot内容的作用域的问题。
试想一下，一个面板主体的内容是一个表单，表单使用v-model绑定了一些值，那么这些绑定的值是属于提供主体内容组件的，还是属于这个面板的呢？
我们来猜想一下:
**属于面板**
如果v-model属于面板的话，那么你有多少的绑定，就需要在面板组件声明多少，而这几乎是不可能的，因为主体内容每个面板都几乎是不一样的，这就造成了，主体内容跟面板的高度藕合，这个面板就几乎没有了任何的可扩展性。
**属于提供主体内容的组件**
由提供主体内容的组件自己去管理自己的绑定，这就好比，面板只提供了一个运动场地，你们爱做什么由你们自己去决定。这样的话，slot插入点跟内容完全解藕，你做你的事情，我只给你提供一个位置。这就是slot的精妙之处。我们不生产内容，我们只是内容的搬运工。
vue的文档已经写得很清楚了
父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件**作用域内编译**
所以在设计一个组件的时候，什么时候使用props，什么时候使用slot呢？
**属于数值驱动的用props，属于html内容的使用slot，除非你的内容只是一句字符串。**简单明了。
**局部变量**
局部变量很好理解，对应于vue的data的而已，这跟函数里面使用var声明一个变量是一样的，唯一要注意的有几点，不要使用$和_作用变量的开头，vue会忽略掉它。
**method:**方法也很好理解，就是给vue调用的方法而已，参考以前在html标签使用的onclick=alert等等
**templete:**组件的html结构，这是必须的选项，毕竟组件是要显示在界面上的.类似于函数的返回值
**name:**对应函数的名字，其实name属性是可选的，就好像函数名也不是必须的，比如匿名函数，那什么时候会用到，函数递归的时候，需要有函数名，那么组件递归的时候也是不可或缺的，参考树组件。

**总结：**
Vuejs学习曲线非常平缓，主要是文档实在太优秀了，旁证了设计师出身的程序员有多可怕。其轻量、高性能的特点，对于移动场景也有很好的契合。更重要的是，设计完备的组件系统和配套的构建工具、插件，使得Vue.js在保留了其简洁API的同时，也已经完全有能力担当起复杂的大型应用的开发。

**其他特性：**
>1. 异步批量DOM更新：当大量数据变动时，所有受到影响的watcher会被推送到一个队列中，并且每个watcher只会推进队列一次。这个队列会在进程的下一个 tick异步执行。这个机制可以避免同一个数据多次变动产生的多余DOM操作，也可以保证所有的DOM写操作在一起执行，避免DOM读写切换可能导致的layout。
2. 动画系统：Vue.js提供了简单却强大的动画系统，当一个元素的可见性变化时，用户不仅可以很简单地定义对应的CSS Transition或Animation效果，还可以利用丰富的JavaScript钩子函数进行更底层的动画处理。
3. 可扩展性：除了自定义指令、过滤器和组件，Vue.js还提供了灵活的mixin机制，让用户可以在多个组件中复用共同的特性。

**搞清楚几个概念：**
Vue.js2.0是一套构建用户界面的渐进式框架，目标是实现数据驱动和组件系统。
 
A 渐进式框架
>1. Vue.js是一个提供MVVM数据双向绑定的库，只专注于UI层面，这是它的核心。它本身没有解决SPA时的路由切换（vue-router），
2. 也没有解决大规模状态管理（vuex），更没有提供工程的构建方式（webpack）。
3. 它给你的是充分的灵活性，在实现过程中，需要在此基础上不断添加配套工具（允许尝试各种想用的方案）。
4. vuejs核心 + 生态圈，是渐进性增强的，是一个在整体选型更为灵活的栈。
 
B 声明式渲染
>1. Vue.js的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进DOM的系统。
2. DOM应尽可能是一个函数式到状态的映射，状态是唯一真相，而DOM是状态的一个映射。
 
C 虚拟DOM渲染过程
>1. Vuejs1.0中，把模板parse成DOM树，然后去遍历这个树，提取其中的各种绑定，这是观察数据与各自watchers取得联系的过程。
2. Vuejs2.0中，引入虚拟DOM，编译器parse模板时转变为render函数，函数被调用时就会返回一个虚拟DOM树。
3. 这个树非常轻量，只负责描述当前界面所应处的状态。有了这个虚拟树后，再交给一个patch函数，负责把虚拟DOM树真正施加到真实的DOM上。
4. 当重新需要渲染时，render会生成一个新的树，将新树与旧树进行对比，得出需做出的改动，再通过patch函数施加修改。

---
### 对比几大框架优缺点
**angular缺点：**是MVC框架，过于厚重。`手动触发或对作用域中所有watcher都求值（脏检查实现方式的缺点）。`可以查阅 [职业吐槽](https://ruby-china.org/topics/27590#reply7)
**angular优点：**成熟，框架完整，架构清晰，工具完备。

**react的缺点：**只是v，开发项目需要配合redux相关东西，不及angularJS完整，其它库需要自己折腾。
**react的优点：**组件式开发，分而治之,大型系统拆分成一个个的小模块小组件,分配给不同的人.额外的好处是顺便能复用这个组件。`轻量级，虚拟DOM的思维，渲染速度有优势。`是mvvm框架，基于`数据驱动`的编程，完全根据`数据的状态`决定ui以何种方式展示。

**Vue缺点：**WEEX不如ReactNative，还在发展当中。
**Vue的优点：**集angular和react优点于一身&解决了两者的缺点。

`详细请参阅： `
[vue.js官网·对比其它框架](https://cn.vuejs.org/v2/guide/comparison.html)
[AngularJs与ReactJS优缺点&适用场景](http://blog.csdn.net/u012125579/article/details/52744093)
[为什么 ReactJS 不适合复杂的前端项目？·放弃JS和React](http://web.jobbole.com/87538/)

### 踩坑完整项目:
>1. [整套饿了么&node&mongodb后台管理](https://github.com/lianmt/node-elm)
2. [整套电影卖座网](https://github.com/lianmt/maizuo)
3. [整套微信](https://github.com/lianmt/vue-weixin)
4. [整套豆瓣](https://github.com/lianmt/douban)

---
### 附录：
程序=数据结构+算法
前端程序 = html+css结构（拼界面+操作ui）+算法
jquery 是零零散散的节点操作

**vue学习阶梯：**
>1. Vue 的响应式机制，状态管理、数据的状态
2. 组件生命周期
3. vue-router、resource、vue-loader、vue-cli、VUEX
4. 组件、插件
5. webpack、node

**深入学习：**
[从JavaScript属性描述器剖析Vue.js响应式视图](https://my.oschina.net/u/3451529/blog/918996)
抱大腿：[bailicangdu](https://github.com/bailicangdu?tab=repositories)

**react完整项目：**
[react + redux 的完整项目](https://github.com/lianmt/react-pxq)
[react-native外卖平台的原生APP](https://github.com/lianmt/RN-elm)

**资源**
[vue应用-框架](https://www.awesomes.cn/subject/vue#应用-框架)

参考链接：
[5Mi17·浅谈Vue.js2.0核心思想](http://www.cnblogs.com/liutie1030/p/6031117.html)
[*vue*js*核心*概念简析 - wefun - SegmentFault](https://www.baidu.com/link?url=mgLBzGT9lFPv1S6X-szYWmEFnAs4re0w7_9xbUuBdJln2jhA_6Dn8k0rXWuDpcVl5478pqtlUAG_sX0bS9jvo_&wd=&eqid=8584ad6b0001a90400000006594a2585)
